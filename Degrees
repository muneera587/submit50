
>>> import csv
 import sys
  from collections import deque, defaultdict

 # Load data from CSV files
 def load_data(directory):
     people = {}
     movies = {}
     stars = defaultdict(list)
     
     # Load people
     with open(f"{directory}/people.csv", encoding="utf-8") as f:
         reader = csv.DictReader(f)
         for row in reader:
             people[row["id"]] = {
                 "name": row["name"],
                 "birth": row["birth"],
                "movies": set()
             }
     
     # Load movies
     with open(f"{directory}/movies.csv", encoding="utf-8") as f:
         reader = csv.DictReader(f)
         for row in reader:
             movies[row["id"]] = {
                 "title": row["title"],
                 "year": row["year"],
                 "stars": set()
             }
     
     # Load stars and connect people with movies
     with open(f"{directory}/stars.csv", encoding="utf-8") as f:
         reader = csv.DictReader(f)
         for row in reader:
        person_id = row["person_id"]
             movie_id = row["movie_id"]
            if person_id in people:
                people[person_id]["movies"].add(movie_id)
            if movie_id in movies:
                movies[movie_id]["stars"].add(person_id)
    
    return people, movies

# Helper to find actor ID by name
def person_id_for_name(name, people):
    for person_id, details in people.items():
        if details["name"].lower() == name.lower():
            return person_id
    return None

# BFS to find the shortest path between two actors
def find_degrees_of_separation(source, target, people, movies):
    # Queue for BFS with paths, starting from source
    queue = deque([[source]])
    visited = set()
    
    while queue:
        path = queue.popleft()
        current_actor = path[-1]
        
        # If we've found the target, return the path
        if current_actor == target:
            return path
        
        # Mark actor as visited
        visited.add(current_actor)
        
        # Add neighboring actors (co-stars in movies)
        for movie_id in people[current_actor]["movies"]:
            for co_star in movies[movie_id]["stars"]:
                if co_star not in visited:
                    queue.append(path + [co_star])
                    visited.add(co_star)
    return None

# Display degrees of separation with movies in the path
def display_degrees(path, people, movies):
    print(f"{len(path) - 1} degrees of separation.")
    for i in range(len(path) - 1):
        actor1 = people[path[i]]["name"]
        actor2 = people[path[i + 1]]["name"]
        # Find the movie they starred in together
        shared_movie = (people[path[i]]["movies"] & people[path[i + 1]]["movies"]).pop()
        movie_title = movies[shared_movie]["title"]
        print(f"{i + 1}: {actor1} and {actor2} starred in {movie_title}")

def main():
    if len(sys.argv) != 2:
        sys.exit("Usage: python degrees.py directory")
    
    directory = sys.argv[1]
    print("Loading data...")
    people, movies = load_data(directory)
    print("Data loaded.")
    
    # Prompt user for names
    source_name = input("Name: ")
    source = person_id_for_name(source_name, people)
    if source is None:
        sys.exit(f"{source_name} not found.")
    
    target_name = input("Name: ")
    target = person_id_for_name(target_name, people)
    if target is None:
        sys.exit(f"{target_name} not found.")
    
    # Find degrees of separation
    path = find_degrees_of_separation(source, target, people, movies)
    if path is None:
        print("Not connected.")
    else:
        display_degrees(path, people, movies)

if __name__ == "__main__":
    main()
